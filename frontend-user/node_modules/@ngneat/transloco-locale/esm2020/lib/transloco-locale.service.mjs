import { Injectable, Inject } from '@angular/core';
import { TranslocoService } from '@ngneat/transloco';
import { BehaviorSubject } from 'rxjs';
import { map, distinctUntilChanged, filter } from 'rxjs/operators';
import { isLocaleFormat, toDate } from './helpers';
import { getDefaultOptions } from './shared';
import { LOCALE_LANG_MAPPING, LOCALE_DEFAULT_LOCALE, LOCALE_CONFIG, LOCALE_CURRENCY_MAPPING, LOCALE_DEFAULT_CURRENCY, } from './transloco-locale.config';
import { TRANSLOCO_DATE_TRANSFORMER, TRANSLOCO_NUMBER_TRANSFORMER, } from './transloco-locale.transformers';
import * as i0 from "@angular/core";
import * as i1 from "@ngneat/transloco";
export class TranslocoLocaleService {
    constructor(translocoService, langLocaleMapping, defaultLocale, defaultCurrency, localeConfig, localeCurrencyMapping, numberTransformer, dateTransformer) {
        this.translocoService = translocoService;
        this.langLocaleMapping = langLocaleMapping;
        this.defaultLocale = defaultLocale;
        this.defaultCurrency = defaultCurrency;
        this.localeConfig = localeConfig;
        this.localeCurrencyMapping = localeCurrencyMapping;
        this.numberTransformer = numberTransformer;
        this.dateTransformer = dateTransformer;
        this._locale = this.defaultLocale || this.toLocale(this.translocoService.getActiveLang());
        this.locale = new BehaviorSubject(this._locale);
        this.subscription = this.translocoService.langChanges$
            .pipe(map(this.toLocale.bind(this)), filter((locale) => !!locale))
            .subscribe({
            next: (locale) => this.setLocale(locale),
        });
        this.localeChanges$ = this.locale
            .asObservable()
            .pipe(distinctUntilChanged());
    }
    getLocale() {
        return this._locale;
    }
    setLocale(locale) {
        if (!isLocaleFormat(locale)) {
            console.error(`${locale} isn't a valid locale format`);
            return;
        }
        this.locale.next(locale);
        this._locale = locale;
    }
    /**
     * Get the currency symbol for the currently set locale.
     */
    getCurrencySymbol(locale = this.getLocale()) {
        const currency = this.localeCurrencyMapping[locale];
        const numberFormat = new Intl.NumberFormat(locale, {
            style: 'currency',
            currencyDisplay: 'symbol',
            currency: currency,
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        });
        const pivot = 0;
        return numberFormat
            .format(pivot)
            .split(pivot.toString())
            .map((element) => element.trim())
            .find((element) => !!element);
    }
    /**
     * Transform a date into the locale's date format.
     *
     * The date expression: a `Date` object, a number
     * (milliseconds since UTC epoch), or an ISO string (https://www.w3.org/TR/NOTE-datetime).
     *
     * @example
     *
     * localizeDate(new Date(2019, 9, 7, 12, 0, 0)) // 10/7/2019
     * localizeDate(date, 'en-US', { dateStyle: 'medium', timeStyle: 'medium' }) // Sep 10, 2019, 10:46:12 PM
     * localizeDate(date) 'en-US', { timeZone: 'UTC', timeStyle: 'full' } // 7:40:32 PM Coordinated Universal Time
     * localizeDate(1, 'en-US', { dateStyle: 'medium' }) // Jan 1, 1970
     * localizeDate('2019-02-08', 'en-US', { dateStyle: 'medium' }) // Feb 8, 2019
     */
    localizeDate(date, locale = this.getLocale(), options = {}) {
        options = options
            ? options
            : getDefaultOptions(locale, 'date', this.localeConfig);
        return this.dateTransformer.transform(toDate(date), locale, options);
    }
    /**
     * Transform a number into the locale's number format according to the number type.
     *
     * localizeNumber(1234567890, 'decimal') // 1,234,567,890
     * localizeNumber(0.5, 'percent') // 50%
     * localizeNumber(1000, 'currency') // $1,000.00
     */
    localizeNumber(value, type, locale = this.getLocale(), options) {
        let resolved = options ?? getDefaultOptions(locale, type, this.localeConfig);
        if (type === 'currency') {
            resolved = {
                ...resolved,
                currency: resolved.currency || this._resolveCurrencyCode(locale),
            };
        }
        return this.numberTransformer.transform(value, type, locale, resolved);
    }
    /**
     * @internal
     */
    _resolveCurrencyCode(locale = this.getLocale()) {
        return this.localeCurrencyMapping[locale] || this.defaultCurrency;
    }
    ngOnDestroy() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.subscription.unsubscribe();
        // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
        // callback within its `destination` property, preventing classes from being GC'd.
        this.subscription = null;
    }
    toLocale(val) {
        if (this.langLocaleMapping[val]) {
            return this.langLocaleMapping[val];
        }
        if (isLocaleFormat(val)) {
            return val;
        }
        return '';
    }
}
TranslocoLocaleService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.0", ngImport: i0, type: TranslocoLocaleService, deps: [{ token: i1.TranslocoService }, { token: LOCALE_LANG_MAPPING }, { token: LOCALE_DEFAULT_LOCALE }, { token: LOCALE_DEFAULT_CURRENCY }, { token: LOCALE_CONFIG }, { token: LOCALE_CURRENCY_MAPPING }, { token: TRANSLOCO_NUMBER_TRANSFORMER }, { token: TRANSLOCO_DATE_TRANSFORMER }], target: i0.ɵɵFactoryTarget.Injectable });
TranslocoLocaleService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.0", ngImport: i0, type: TranslocoLocaleService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.0", ngImport: i0, type: TranslocoLocaleService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslocoService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_LANG_MAPPING]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_DEFAULT_LOCALE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_DEFAULT_CURRENCY]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_CONFIG]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_CURRENCY_MAPPING]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_NUMBER_TRANSFORMER]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSLOCO_DATE_TRANSFORMER]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLWxvY2FsZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy90cmFuc2xvY28tbG9jYWxlL3NyYy9saWIvdHJhbnNsb2NvLWxvY2FsZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzlELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3JELE9BQU8sRUFBYyxlQUFlLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQ2pFLE9BQU8sRUFBRSxHQUFHLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzdDLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIscUJBQXFCLEVBQ3JCLGFBQWEsRUFDYix1QkFBdUIsRUFDdkIsdUJBQXVCLEdBQ3hCLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUNMLDBCQUEwQixFQUMxQiw0QkFBNEIsR0FHN0IsTUFBTSxpQ0FBaUMsQ0FBQzs7O0FBZXpDLE1BQU0sT0FBTyxzQkFBc0I7SUFjakMsWUFDVSxnQkFBa0MsRUFDTCxpQkFBc0MsRUFDcEMsYUFBcUIsRUFDbkIsZUFBeUIsRUFDbkMsWUFBMEIsRUFFakQscUJBQThDLEVBRTlDLGlCQUE2QyxFQUU3QyxlQUF5QztRQVZ6QyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ0wsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFxQjtRQUNwQyxrQkFBYSxHQUFiLGFBQWEsQ0FBUTtRQUNuQixvQkFBZSxHQUFmLGVBQWUsQ0FBVTtRQUNuQyxpQkFBWSxHQUFaLFlBQVksQ0FBYztR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LG1CQUFtQixhQUNuQixxQkFBcUIsYUFDckIsdUJBQXVCLGFBQ3ZCLGFBQWEsYUFDYix1QkFBdUIsYUFFdkIsNEJBQTRCLGFBRTVCLDBCQUEwQjt1SEF4QnpCLHNCQUFzQixjQUZyQixNQUFNOzJGQUVQLHNCQUFzQjtrQkFIbEMsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkI7OzBCQWlCSSxNQUFNOzJCQUFDLG1CQUFtQjs7MEJBQzFCLE1BQU07MkJBQUMscUJBQXFCOzswQkFDNUIsTUFBTTsyQkFBQyx1QkFBdUI7OzBCQUM5QixNQUFNOzJCQUFDLGFBQWE7OzBCQUNwQixNQUFNOzJCQUFDLHVCQUF1Qjs7MEJBRTlCLE1BQU07MkJBQUMsNEJBQTRCOzswQkFFbkMsTUFBTTsyQkFBQywwQkFBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJhbnNsb2NvU2VydmljZSB9IGZyb20gJ0BuZ25lYXQvdHJhbnNsb2NvJztcbmltcG9ydCB7IE9ic2VydmFibGUsIEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBpc0xvY2FsZUZvcm1hdCwgdG9EYXRlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGdldERlZmF1bHRPcHRpb25zIH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHtcbiAgTE9DQUxFX0xBTkdfTUFQUElORyxcbiAgTE9DQUxFX0RFRkFVTFRfTE9DQUxFLFxuICBMT0NBTEVfQ09ORklHLFxuICBMT0NBTEVfQ1VSUkVOQ1lfTUFQUElORyxcbiAgTE9DQUxFX0RFRkFVTFRfQ1VSUkVOQ1ksXG59IGZyb20gJy4vdHJhbnNsb2NvLWxvY2FsZS5jb25maWcnO1xuaW1wb3J0IHtcbiAgVFJBTlNMT0NPX0RBVEVfVFJBTlNGT1JNRVIsXG4gIFRSQU5TTE9DT19OVU1CRVJfVFJBTlNGT1JNRVIsXG4gIFRyYW5zbG9jb0RhdGVUcmFuc2Zvcm1lcixcbiAgVHJhbnNsb2NvTnVtYmVyVHJhbnNmb3JtZXIsXG59IGZyb20gJy4vdHJhbnNsb2NvLWxvY2FsZS50cmFuc2Zvcm1lcnMnO1xuaW1wb3J0IHtcbiAgTG9jYWxlLFxuICBEYXRlRm9ybWF0T3B0aW9ucyxcbiAgTnVtYmVyVHlwZXMsXG4gIEN1cnJlbmN5LFxuICBWYWxpZERhdGUsXG4gIExvY2FsZUNvbmZpZyxcbiAgTG9jYWxlVG9DdXJyZW5jeU1hcHBpbmcsXG4gIExhbmdUb0xvY2FsZU1hcHBpbmcsXG59IGZyb20gJy4vdHJhbnNsb2NvLWxvY2FsZS50eXBlcyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2xvY29Mb2NhbGVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgbG9jYWxlQ2hhbmdlcyQ6IE9ic2VydmFibGU8TG9jYWxlPjtcbiAgcHJpdmF0ZSBfbG9jYWxlID1cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgfHwgdGhpcy50b0xvY2FsZSh0aGlzLnRyYW5zbG9jb1NlcnZpY2UuZ2V0QWN0aXZlTGFuZygpKTtcbiAgcHJpdmF0ZSBsb2NhbGU6IEJlaGF2aW9yU3ViamVjdDxMb2NhbGU+ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLl9sb2NhbGUpO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IHRoaXMudHJhbnNsb2NvU2VydmljZS5sYW5nQ2hhbmdlcyRcbiAgICAucGlwZShcbiAgICAgIG1hcCh0aGlzLnRvTG9jYWxlLmJpbmQodGhpcykpLFxuICAgICAgZmlsdGVyKChsb2NhbGUpID0+ICEhbG9jYWxlKVxuICAgIClcbiAgICAuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChsb2NhbGU6IExvY2FsZSkgPT4gdGhpcy5zZXRMb2NhbGUobG9jYWxlKSxcbiAgICB9KTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRyYW5zbG9jb1NlcnZpY2U6IFRyYW5zbG9jb1NlcnZpY2UsXG4gICAgQEluamVjdChMT0NBTEVfTEFOR19NQVBQSU5HKSBwcml2YXRlIGxhbmdMb2NhbGVNYXBwaW5nOiBMYW5nVG9Mb2NhbGVNYXBwaW5nLFxuICAgIEBJbmplY3QoTE9DQUxFX0RFRkFVTFRfTE9DQUxFKSBwcml2YXRlIGRlZmF1bHRMb2NhbGU6IExvY2FsZSxcbiAgICBASW5qZWN0KExPQ0FMRV9ERUZBVUxUX0NVUlJFTkNZKSBwcml2YXRlIGRlZmF1bHRDdXJyZW5jeTogQ3VycmVuY3ksXG4gICAgQEluamVjdChMT0NBTEVfQ09ORklHKSBwcml2YXRlIGxvY2FsZUNvbmZpZzogTG9jYWxlQ29uZmlnLFxuICAgIEBJbmplY3QoTE9DQUxFX0NVUlJFTkNZX01BUFBJTkcpXG4gICAgcHJpdmF0ZSBsb2NhbGVDdXJyZW5jeU1hcHBpbmc6IExvY2FsZVRvQ3VycmVuY3lNYXBwaW5nLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX05VTUJFUl9UUkFOU0ZPUk1FUilcbiAgICBwcml2YXRlIG51bWJlclRyYW5zZm9ybWVyOiBUcmFuc2xvY29OdW1iZXJUcmFuc2Zvcm1lcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19EQVRFX1RSQU5TRk9STUVSKVxuICAgIHByaXZhdGUgZGF0ZVRyYW5zZm9ybWVyOiBUcmFuc2xvY29EYXRlVHJhbnNmb3JtZXJcbiAgKSB7XG4gICAgdGhpcy5sb2NhbGVDaGFuZ2VzJCA9IHRoaXMubG9jYWxlXG4gICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICB9XG5cbiAgZ2V0TG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH1cblxuICBzZXRMb2NhbGUobG9jYWxlOiBMb2NhbGUpIHtcbiAgICBpZiAoIWlzTG9jYWxlRm9ybWF0KGxvY2FsZSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYCR7bG9jYWxlfSBpc24ndCBhIHZhbGlkIGxvY2FsZSBmb3JtYXRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvY2FsZS5uZXh0KGxvY2FsZSk7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVuY3kgc3ltYm9sIGZvciB0aGUgY3VycmVudGx5IHNldCBsb2NhbGUuXG4gICAqL1xuICBnZXRDdXJyZW5jeVN5bWJvbChsb2NhbGUgPSB0aGlzLmdldExvY2FsZSgpKSB7XG4gICAgY29uc3QgY3VycmVuY3kgPSB0aGlzLmxvY2FsZUN1cnJlbmN5TWFwcGluZ1tsb2NhbGVdO1xuICAgIGNvbnN0IG51bWJlckZvcm1hdCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcbiAgICAgIHN0eWxlOiAnY3VycmVuY3knLFxuICAgICAgY3VycmVuY3lEaXNwbGF5OiAnc3ltYm9sJyxcbiAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBpdm90ID0gMDtcblxuICAgIHJldHVybiBudW1iZXJGb3JtYXRcbiAgICAgIC5mb3JtYXQocGl2b3QpXG4gICAgICAuc3BsaXQocGl2b3QudG9TdHJpbmcoKSlcbiAgICAgIC5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQudHJpbSgpKVxuICAgICAgLmZpbmQoKGVsZW1lbnQpID0+ICEhZWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgZGF0ZSBpbnRvIHRoZSBsb2NhbGUncyBkYXRlIGZvcm1hdC5cbiAgICpcbiAgICogVGhlIGRhdGUgZXhwcmVzc2lvbjogYSBgRGF0ZWAgb2JqZWN0LCBhIG51bWJlclxuICAgKiAobWlsbGlzZWNvbmRzIHNpbmNlIFVUQyBlcG9jaCksIG9yIGFuIElTTyBzdHJpbmcgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9OT1RFLWRhdGV0aW1lKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogbG9jYWxpemVEYXRlKG5ldyBEYXRlKDIwMTksIDksIDcsIDEyLCAwLCAwKSkgLy8gMTAvNy8yMDE5XG4gICAqIGxvY2FsaXplRGF0ZShkYXRlLCAnZW4tVVMnLCB7IGRhdGVTdHlsZTogJ21lZGl1bScsIHRpbWVTdHlsZTogJ21lZGl1bScgfSkgLy8gU2VwIDEwLCAyMDE5LCAxMDo0NjoxMiBQTVxuICAgKiBsb2NhbGl6ZURhdGUoZGF0ZSkgJ2VuLVVTJywgeyB0aW1lWm9uZTogJ1VUQycsIHRpbWVTdHlsZTogJ2Z1bGwnIH0gLy8gNzo0MDozMiBQTSBDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZVxuICAgKiBsb2NhbGl6ZURhdGUoMSwgJ2VuLVVTJywgeyBkYXRlU3R5bGU6ICdtZWRpdW0nIH0pIC8vIEphbiAxLCAxOTcwXG4gICAqIGxvY2FsaXplRGF0ZSgnMjAxOS0wMi0wOCcsICdlbi1VUycsIHsgZGF0ZVN0eWxlOiAnbWVkaXVtJyB9KSAvLyBGZWIgOCwgMjAxOVxuICAgKi9cbiAgbG9jYWxpemVEYXRlKFxuICAgIGRhdGU6IFZhbGlkRGF0ZSxcbiAgICBsb2NhbGU6IExvY2FsZSA9IHRoaXMuZ2V0TG9jYWxlKCksXG4gICAgb3B0aW9uczogRGF0ZUZvcm1hdE9wdGlvbnMgPSB7fVxuICApOiBzdHJpbmcge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgICA/IG9wdGlvbnNcbiAgICAgIDogZ2V0RGVmYXVsdE9wdGlvbnMobG9jYWxlLCAnZGF0ZScsIHRoaXMubG9jYWxlQ29uZmlnKTtcblxuICAgIHJldHVybiB0aGlzLmRhdGVUcmFuc2Zvcm1lci50cmFuc2Zvcm0odG9EYXRlKGRhdGUpLCBsb2NhbGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBhIG51bWJlciBpbnRvIHRoZSBsb2NhbGUncyBudW1iZXIgZm9ybWF0IGFjY29yZGluZyB0byB0aGUgbnVtYmVyIHR5cGUuXG4gICAqXG4gICAqIGxvY2FsaXplTnVtYmVyKDEyMzQ1Njc4OTAsICdkZWNpbWFsJykgLy8gMSwyMzQsNTY3LDg5MFxuICAgKiBsb2NhbGl6ZU51bWJlcigwLjUsICdwZXJjZW50JykgLy8gNTAlXG4gICAqIGxvY2FsaXplTnVtYmVyKDEwMDAsICdjdXJyZW5jeScpIC8vICQxLDAwMC4wMFxuICAgKi9cbiAgbG9jYWxpemVOdW1iZXIoXG4gICAgdmFsdWU6IG51bWJlciB8IHN0cmluZyxcbiAgICB0eXBlOiBOdW1iZXJUeXBlcyxcbiAgICBsb2NhbGU6IExvY2FsZSA9IHRoaXMuZ2V0TG9jYWxlKCksXG4gICAgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9uc1xuICApOiBzdHJpbmcge1xuICAgIGxldCByZXNvbHZlZCA9XG4gICAgICBvcHRpb25zID8/IGdldERlZmF1bHRPcHRpb25zKGxvY2FsZSwgdHlwZSwgdGhpcy5sb2NhbGVDb25maWcpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgIHJlc29sdmVkID0ge1xuICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgY3VycmVuY3k6IHJlc29sdmVkLmN1cnJlbmN5IHx8IHRoaXMuX3Jlc29sdmVDdXJyZW5jeUNvZGUobG9jYWxlKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubnVtYmVyVHJhbnNmb3JtZXIudHJhbnNmb3JtKHZhbHVlLCB0eXBlLCBsb2NhbGUsIHJlc29sdmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9yZXNvbHZlQ3VycmVuY3lDb2RlKGxvY2FsZTogTG9jYWxlID0gdGhpcy5nZXRMb2NhbGUoKSkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZUN1cnJlbmN5TWFwcGluZ1tsb2NhbGVdIHx8IHRoaXMuZGVmYXVsdEN1cnJlbmN5O1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICB0aGlzLnN1YnNjcmlwdGlvbiEudW5zdWJzY3JpYmUoKTtcbiAgICAvLyBDYXJldGFrZXIgbm90ZTogaXQncyBpbXBvcnRhbnQgdG8gY2xlYW4gdXAgcmVmZXJlbmNlcyB0byBzdWJzY3JpcHRpb25zIHNpbmNlIHRoZXkgc2F2ZSB0aGUgYG5leHRgXG4gICAgLy8gY2FsbGJhY2sgd2l0aGluIGl0cyBgZGVzdGluYXRpb25gIHByb3BlcnR5LCBwcmV2ZW50aW5nIGNsYXNzZXMgZnJvbSBiZWluZyBHQydkLlxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgdG9Mb2NhbGUodmFsOiBzdHJpbmcgfCBMb2NhbGUpOiBMb2NhbGUge1xuICAgIGlmICh0aGlzLmxhbmdMb2NhbGVNYXBwaW5nW3ZhbF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmdMb2NhbGVNYXBwaW5nW3ZhbF07XG4gICAgfVxuXG4gICAgaWYgKGlzTG9jYWxlRm9ybWF0KHZhbCkpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4iXX0=