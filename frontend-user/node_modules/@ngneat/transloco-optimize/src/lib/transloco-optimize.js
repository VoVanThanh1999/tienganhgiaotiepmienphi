"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimizeFiles = exports.getTranslationFiles = exports.getTranslationsFolder = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const glob_1 = tslib_1.__importDefault(require("glob"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const flat_1 = require("flat");
function removeComments(translation, commentsKey = 'comment') {
    return Object.keys(translation).reduce((acc, key) => {
        const lastKey = key.split('.').pop();
        if (lastKey !== commentsKey) {
            acc[key] = translation[key];
        }
        return acc;
    }, {});
}
function getTranslationsFolder(dist) {
    return path_1.default.resolve(process.cwd(), dist);
}
exports.getTranslationsFolder = getTranslationsFolder;
function getTranslationFiles(dist) {
    const filesMatcher = path_1.default.resolve(getTranslationsFolder(dist), '**/*.json');
    return util_1.promisify(glob_1.default)(filesMatcher, {});
}
exports.getTranslationFiles = getTranslationFiles;
function optimizeFiles(translationPaths, commentsKey) {
    return new Promise((resolve, reject) => {
        let error;
        for (const path of translationPaths) {
            try {
                const translation = fs_1.default.readFileSync(path, { encoding: 'utf8' });
                const asObject = JSON.parse(translation);
                const flatObject = flat_1.flatten(asObject, { safe: true });
                const optimized = JSON.stringify(removeComments(flatObject, commentsKey));
                fs_1.default.writeFileSync(path, optimized, { encoding: 'utf8' });
            }
            catch (err) {
                error = err;
                break;
            }
        }
        if (error) {
            reject(error);
        }
        else {
            resolve();
        }
    });
}
exports.optimizeFiles = optimizeFiles;
