import { ɵɵdefineInjectable, ɵɵinject, Injectable, Directive, Optional, NgModule } from '@angular/core';
import { Router, PRIMARY_OUTLET, RouterPreloader, RouterLink, RouterLinkWithHref } from '@angular/router';
import { EMPTY } from 'rxjs';

class RegistryService {
    constructor(router) {
        this.router = router;
        // Using a map so we don't add an element
        // on each hover. This will generally reduce memory
        // usage and will not require cleanup.
        this._queue = new Set([]);
    }
    add(route) {
        this._queue.add(route);
    }
    shouldPrefetch(url) {
        const tree = this.router.parseUrl(url);
        return [...this._queue].some(containsTree.bind(null, tree));
    }
}
RegistryService.ɵprov = ɵɵdefineInjectable({ factory: function RegistryService_Factory() { return new RegistryService(ɵɵinject(Router)); }, token: RegistryService, providedIn: "root" });
RegistryService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
RegistryService.ctorParameters = () => [
    { type: Router }
];
function containsQueryParams(container, containee) {
    // TODO: This does not handle array params correctly.
    return (Object.keys(containee).length <= Object.keys(container).length &&
        Object.keys(containee).every(key => containee[key] === container[key]));
}
function containsTree(containee, container) {
    return (containsQueryParams(container.queryParams, containee.queryParams) &&
        containsSegmentGroup(container.root, containee.root, containee.root.segments));
}
function containsSegmentGroup(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
        const current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths))
            return false;
        if (containee.hasChildren())
            return false;
        return true;
    }
    else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths))
            return false;
        if (!containee.hasChildren())
            return true;
        for (const c in containee.children) {
            if (!container.children[c])
                break;
            if (containsSegmentGroup(container.children[c], containee.children[c], containee.children[c].segments))
                return true;
        }
        return false;
    }
    else {
        const current = containeePaths.slice(0, container.segments.length);
        const next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, current))
            return false;
        if (!container.children[PRIMARY_OUTLET])
            return false;
        return containsSegmentGroup(container.children[PRIMARY_OUTLET], containee, next);
    }
}
function equalPath(as, bs) {
    if (as.length !== bs.length)
        return false;
    return as.every((a, i) => a.path === bs[i].path || a.path.startsWith(':') || bs[i].path.startsWith(':'));
}

class LinkDirective {
    constructor(_loader, _registry, link, linkWithHref) {
        this._loader = _loader;
        this._registry = _registry;
        this._rl = link || linkWithHref;
    }
    prefetch() {
        requestIdleCallback(() => {
            this._registry.add(this._rl.urlTree);
            this._loader.preload().subscribe(() => void 0);
        });
    }
}
LinkDirective.decorators = [
    { type: Directive, args: [{
                selector: '[routerLink]',
                host: {
                    '(mouseenter)': 'prefetch()'
                }
            },] }
];
LinkDirective.ctorParameters = () => [
    { type: RouterPreloader },
    { type: RegistryService },
    { type: RouterLink, decorators: [{ type: Optional }] },
    { type: RouterLinkWithHref, decorators: [{ type: Optional }] }
];
const ɵ0 = function (cb) {
    const start = Date.now();
    return setTimeout(function () {
        cb({
            didTimeout: false,
            timeRemaining: function () {
                return Math.max(0, 50 - (Date.now() - start));
            }
        });
    }, 1);
}, ɵ1 = () => { };
const requestIdleCallback = typeof window !== 'undefined'
    ? window.requestIdleCallback || ɵ0
    : ɵ1;

class HoverPreloadStrategy {
    constructor(_router, _registry) {
        this._router = _router;
        this._registry = _registry;
        this._loading = new Set();
    }
    preload(route, load) {
        if (this._loading.has(route)) {
            // Don't preload the same route twice
            return EMPTY;
        }
        // Prevent from preloading
        if (route.data && route.data.preload === false) {
            return EMPTY;
        }
        const path = findPath(this._router.config, route);
        if (this._registry.shouldPrefetch(path)) {
            this._loading.add(route);
            return load();
        }
        return EMPTY;
    }
}
HoverPreloadStrategy.decorators = [
    { type: Injectable }
];
HoverPreloadStrategy.ctorParameters = () => [
    { type: Router },
    { type: RegistryService }
];
const findPath = (config, route) => {
    config = config.slice();
    const parent = new Map();
    const visited = new Set();
    while (config.length) {
        const el = config.shift();
        if (!el) {
            break;
        }
        visited.add(el);
        if (el === route)
            break;
        let children = el.children || [];
        const current = el._loadedConfig;
        if (current && current.routes) {
            children = children.concat(current.routes);
        }
        children.forEach((r) => {
            if (visited.has(r))
                return;
            parent.set(r, el);
            config.push(r);
        });
    }
    let path = '';
    let current = route;
    while (current) {
        if (isPrimaryRoute(current)) {
            path = `/${current.path}${path}`;
        }
        else {
            path = `/(${current.outlet}:${current.path}${path})`;
        }
        current = parent.get(current);
    }
    return path;
};
const ɵ0$1 = findPath;
function isPrimaryRoute(route) {
    return route.outlet === PRIMARY_OUTLET || !route.outlet;
}

class HoverPreloadModule {
}
HoverPreloadModule.decorators = [
    { type: NgModule, args: [{
                declarations: [LinkDirective],
                imports: [],
                providers: [HoverPreloadStrategy],
                exports: [LinkDirective]
            },] }
];

/*
 * Public API Surface of ngx-hover-preload
 */

/**
 * Generated bundle index. Do not edit.
 */

export { HoverPreloadModule, HoverPreloadStrategy, RegistryService as ɵa, LinkDirective as ɵɵLinkDirective };
//# sourceMappingURL=ngx-hover-preload.js.map
