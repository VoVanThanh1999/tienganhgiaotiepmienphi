import { ɵɵdefineInjectable, ɵɵinject, Injectable, Directive, Optional, NgModule } from '@angular/core';
import { Router, PRIMARY_OUTLET, RouterPreloader, RouterLink, RouterLinkWithHref } from '@angular/router';
import { EMPTY } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
class RegistryService {
    constructor(router) {
        this.router = router;
        // Using a map so we don't add an element
        // on each hover. This will generally reduce memory
        // usage and will not require cleanup.
        this._queue = new Set([]);
    }
    add(route) {
        this._queue.add(route);
    }
    shouldPrefetch(url) {
        const tree = this.router.parseUrl(url);
        return [...this._queue].some(containsTree.bind(null, tree));
    }
}
RegistryService.ɵfac = function RegistryService_Factory(t) { return new (t || RegistryService)(ɵngcc0.ɵɵinject(ɵngcc1.Router)); };
RegistryService.ɵprov = ɵɵdefineInjectable({ factory: function RegistryService_Factory() { return new RegistryService(ɵɵinject(Router)); }, token: RegistryService, providedIn: "root" });
RegistryService.ctorParameters = () => [
    { type: Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RegistryService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.Router }]; }, null); })();
function containsQueryParams(container, containee) {
    // TODO: This does not handle array params correctly.
    return (Object.keys(containee).length <= Object.keys(container).length &&
        Object.keys(containee).every(key => containee[key] === container[key]));
}
function containsTree(containee, container) {
    return (containsQueryParams(container.queryParams, containee.queryParams) &&
        containsSegmentGroup(container.root, containee.root, containee.root.segments));
}
function containsSegmentGroup(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
        const current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths))
            return false;
        if (containee.hasChildren())
            return false;
        return true;
    }
    else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths))
            return false;
        if (!containee.hasChildren())
            return true;
        for (const c in containee.children) {
            if (!container.children[c])
                break;
            if (containsSegmentGroup(container.children[c], containee.children[c], containee.children[c].segments))
                return true;
        }
        return false;
    }
    else {
        const current = containeePaths.slice(0, container.segments.length);
        const next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, current))
            return false;
        if (!container.children[PRIMARY_OUTLET])
            return false;
        return containsSegmentGroup(container.children[PRIMARY_OUTLET], containee, next);
    }
}
function equalPath(as, bs) {
    if (as.length !== bs.length)
        return false;
    return as.every((a, i) => a.path === bs[i].path || a.path.startsWith(':') || bs[i].path.startsWith(':'));
}

class LinkDirective {
    constructor(_loader, _registry, link, linkWithHref) {
        this._loader = _loader;
        this._registry = _registry;
        this._rl = link || linkWithHref;
    }
    prefetch() {
        requestIdleCallback(() => {
            this._registry.add(this._rl.urlTree);
            this._loader.preload().subscribe(() => void 0);
        });
    }
}
LinkDirective.ɵfac = function LinkDirective_Factory(t) { return new (t || LinkDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.RouterPreloader), ɵngcc0.ɵɵdirectiveInject(RegistryService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.RouterLink, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.RouterLinkWithHref, 8)); };
LinkDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: LinkDirective, selectors: [["", "routerLink", ""]], hostBindings: function LinkDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function LinkDirective_mouseenter_HostBindingHandler() { return ctx.prefetch(); });
    } } });
LinkDirective.ctorParameters = () => [
    { type: RouterPreloader },
    { type: RegistryService },
    { type: RouterLink, decorators: [{ type: Optional }] },
    { type: RouterLinkWithHref, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinkDirective, [{
        type: Directive,
        args: [{
                selector: '[routerLink]',
                host: {
                    '(mouseenter)': 'prefetch()'
                }
            }]
    }], function () { return [{ type: ɵngcc1.RouterPreloader }, { type: RegistryService }, { type: ɵngcc1.RouterLink, decorators: [{
                type: Optional
            }] }, { type: ɵngcc1.RouterLinkWithHref, decorators: [{
                type: Optional
            }] }]; }, null); })();
const ɵ0 = function (cb) {
    const start = Date.now();
    return setTimeout(function () {
        cb({
            didTimeout: false,
            timeRemaining: function () {
                return Math.max(0, 50 - (Date.now() - start));
            }
        });
    }, 1);
}, ɵ1 = () => { };
const requestIdleCallback = typeof window !== 'undefined'
    ? window.requestIdleCallback || ɵ0
    : ɵ1;

class HoverPreloadStrategy {
    constructor(_router, _registry) {
        this._router = _router;
        this._registry = _registry;
        this._loading = new Set();
    }
    preload(route, load) {
        if (this._loading.has(route)) {
            // Don't preload the same route twice
            return EMPTY;
        }
        // Prevent from preloading
        if (route.data && route.data.preload === false) {
            return EMPTY;
        }
        const path = findPath(this._router.config, route);
        if (this._registry.shouldPrefetch(path)) {
            this._loading.add(route);
            return load();
        }
        return EMPTY;
    }
}
HoverPreloadStrategy.ɵfac = function HoverPreloadStrategy_Factory(t) { return new (t || HoverPreloadStrategy)(ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(RegistryService)); };
HoverPreloadStrategy.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: HoverPreloadStrategy, factory: HoverPreloadStrategy.ɵfac });
HoverPreloadStrategy.ctorParameters = () => [
    { type: Router },
    { type: RegistryService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HoverPreloadStrategy, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Router }, { type: RegistryService }]; }, null); })();
const findPath = (config, route) => {
    config = config.slice();
    const parent = new Map();
    const visited = new Set();
    while (config.length) {
        const el = config.shift();
        if (!el) {
            break;
        }
        visited.add(el);
        if (el === route)
            break;
        let children = el.children || [];
        const current = el._loadedConfig;
        if (current && current.routes) {
            children = children.concat(current.routes);
        }
        children.forEach((r) => {
            if (visited.has(r))
                return;
            parent.set(r, el);
            config.push(r);
        });
    }
    let path = '';
    let current = route;
    while (current) {
        if (isPrimaryRoute(current)) {
            path = `/${current.path}${path}`;
        }
        else {
            path = `/(${current.outlet}:${current.path}${path})`;
        }
        current = parent.get(current);
    }
    return path;
};
const ɵ0$1 = findPath;
function isPrimaryRoute(route) {
    return route.outlet === PRIMARY_OUTLET || !route.outlet;
}

class HoverPreloadModule {
}
HoverPreloadModule.ɵfac = function HoverPreloadModule_Factory(t) { return new (t || HoverPreloadModule)(); };
HoverPreloadModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: HoverPreloadModule });
HoverPreloadModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [HoverPreloadStrategy] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HoverPreloadModule, [{
        type: NgModule,
        args: [{
                declarations: [LinkDirective],
                imports: [],
                providers: [HoverPreloadStrategy],
                exports: [LinkDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HoverPreloadModule, { declarations: [LinkDirective], exports: [LinkDirective] }); })();

/*
 * Public API Surface of ngx-hover-preload
 */

/**
 * Generated bundle index. Do not edit.
 */

export { HoverPreloadModule, HoverPreloadStrategy, RegistryService as ɵa, LinkDirective as ɵɵLinkDirective };

//# sourceMappingURL=ngx-hover-preload.js.map