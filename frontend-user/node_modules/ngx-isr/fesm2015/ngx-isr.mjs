import * as i0 from '@angular/core';
import { PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';
import { isPlatformServer, DOCUMENT, APP_BASE_HREF } from '@angular/common';
import * as i1 from '@angular/router';
import { ChildActivationEnd } from '@angular/router';
import { filter, map, take } from 'rxjs/operators';
import { BehaviorSubject, catchError, throwError } from 'rxjs';
import { __awaiter } from 'tslib';
import * as fs from 'fs';
import { join } from 'path';
import { ÉµSERVER_CONTEXT, BEFORE_APP_SERIALIZED } from '@angular/platform-server';
import { HTTP_INTERCEPTORS } from '@angular/common/http';

const initialState = {
    revalidate: null,
    errors: [],
    extra: {}
};
class NgxIsrService {
    constructor(platformId, doc, router) {
        this.platformId = platformId;
        this.doc = doc;
        this.router = router;
        this.state = new BehaviorSubject(initialState);
        this.setRevalidate = (revalidate) => {
            this.state.next(Object.assign(Object.assign({}, this.getState()), { revalidate }));
        };
        if (isPlatformServer(this.platformId)) {
            this.activate();
        }
    }
    getState() {
        return this.state.getValue();
    }
    getExtra() {
        return this.state.getValue().extra;
    }
    activate() {
        this.router.events
            .pipe(filter((e) => e instanceof ChildActivationEnd), map((event) => {
            let snapshot = event.snapshot;
            while (snapshot.firstChild !== null) {
                snapshot = snapshot.firstChild;
            }
            return snapshot.data;
        }), take(1))
            .subscribe((data) => {
            if ((data === null || data === void 0 ? void 0 : data['revalidate']) !== undefined) {
                this.setRevalidate(data['revalidate']);
            }
        });
    }
    addError(err) {
        const currentErrors = this.getState().errors;
        this.state.next(Object.assign(Object.assign({}, this.getState()), { errors: [...currentErrors, err] }));
    }
    addExtra(extra = {}) {
        this.state.next(Object.assign(Object.assign({}, this.getState()), { extra: Object.assign(Object.assign({}, this.getExtra()), extra) }));
    }
}
NgxIsrService.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrService, deps: [{ token: PLATFORM_ID }, { token: DOCUMENT }, { token: i1.Router }], target: i0.ÉµÉµFactoryTarget.Injectable });
NgxIsrService.Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrService, providedIn: 'root' });
i0.ÉµÉµngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () {
        return [{ type: Object, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }, { type: Document, decorators: [{
                        type: Inject,
                        args: [DOCUMENT]
                    }] }, { type: i1.Router }];
    } });

class CacheHandler {
}

// this script tag will be included in the page if one of the routes on the page
// has `revalidate` key in its route data
const isrScriptTag = '<script id="isr-state" type="application/json">';
function getISROptions(html) {
    const indexOfScriptTag = html === null || html === void 0 ? void 0 : html.indexOf(isrScriptTag);
    // check if script tag is not included
    if (!html || indexOfScriptTag === -1) {
        return { revalidate: null, errors: [] };
    }
    const isrScript = html.substring(indexOfScriptTag); // start from script till the end of html file
    const indexOfCloseScriptTag = isrScript.indexOf("</script>"); // first occurrence of closing script tag
    const val = isrScript
        .substring(0, indexOfCloseScriptTag) // remove close script tag
        .replace(isrScriptTag, ""); // remove start script tag
    return JSON.parse(val);
}

class FileSystemCacheHandler {
    constructor(options) {
        this.options = options;
        this.cache = new Map();
        if (!options.cacheFolderPath) {
            throw new Error('Cache folder path is required!');
        }
        if (options.addPrerenderedPagesToCache && !options.prerenderedPagesPath) {
            throw new Error('Prerendered pages path is required when `addPrerenderedPagesToCache` is enabled!');
        }
        this.options = options;
        this.populateCacheFromFilesystem();
    }
    get cacheFolderPath() {
        return this.options.cacheFolderPath;
    }
    add(route, html, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                route = route.charAt(0) === '/' ? route.slice(1) : route;
                const fileName = convertRouteToFileName(route);
                const filePath = `${this.getFileFullPath(fileName)}.html`;
                fs.writeFile(filePath, html, 'utf-8', (err) => {
                    if (err) {
                        reject('Error: ðŸ’¥ The request was not cached!');
                    }
                    this.cache.set(route, {
                        html: filePath,
                        options: options || { revalidate: null },
                        createdAt: Date.now(),
                    });
                    console.log('The request was cached!', route);
                    resolve();
                });
            });
        });
    }
    get(route) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const cachedUrl = this.cache.get(route);
            if (cachedUrl) {
                // on html field we have saved path to file
                const html = yield this.readFromFile(cachedUrl.html);
                const cacheData = Object.assign(Object.assign({}, cachedUrl), { html });
                resolve(cacheData);
            }
            else {
                reject('Error: ðŸ’¥ Url is not cached.');
            }
        }));
    }
    has(url) {
        return Promise.resolve(this.cache.has(url));
    }
    delete(url) {
        return new Promise((resolve, reject) => {
            const cachedUrl = this.cache.get(url);
            if (cachedUrl) {
                const filePath = this.getFileFullPath(url);
                fs.unlink(cachedUrl.html, (err) => {
                    if (err) {
                        reject('Error: ðŸ’¥ Cannot delete file' + filePath);
                    }
                    else {
                        this.cache.delete(url);
                        resolve(true);
                    }
                });
            }
            else {
                reject('Error: ðŸ’¥ Url is not cached.');
            }
        });
    }
    getAll() {
        const data = Array.from(this.cache.keys());
        return Promise.resolve(data);
    }
    populateCacheFromFilesystem() {
        if (!fs.existsSync(this.cacheFolderPath)) {
            console.log('Cache folder does not exist. Creating...');
            fs.mkdir(this.cacheFolderPath, (err) => {
                if (!err) {
                    console.log('Cache folder was created.');
                }
            });
        }
        if (this.options.addPrerenderedPagesToCache) {
            console.log('Adding prerendered pages to cache...');
            this.addPrerenderedPagesToCache();
        }
    }
    addPrerenderedPagesToCache() {
        // read all folders in browser folder and check if they have index.html inside
        // if yes add the folder name to cache as url and index.html as html
        // then remove the found files because they will be handled by ISR
        const folderPath = this.options.prerenderedPagesPath;
        const pathsToCache = [];
        try {
            const files = fs.readdirSync(folderPath);
            for (const file of files) {
                const filePath = join(folderPath, file);
                const isDirectory = fs.statSync(filePath).isDirectory();
                if (isDirectory) {
                    const indexHtmlFiles = findIndexHtmlFilesRecursively(filePath);
                    pathsToCache.push(...indexHtmlFiles.map(({ path, html }) => ({
                        path: path.replace(folderPath, ''),
                        html,
                    })));
                }
            }
        }
        catch (err) {
            console.error('ERROR! ðŸ’¥ ! Cannot read folder: ' + folderPath);
        }
        for (const { path, html } of pathsToCache) {
            const routePath = path.substring(0).replace('/index.html', '');
            const { revalidate, errors } = getISROptions(html);
            this.add(routePath, html, { revalidate, errors });
        }
        for (const { path } of pathsToCache) {
            const file = join(this.options.prerenderedPagesPath, path);
            fs.rmSync(file, { recursive: true, force: true });
        }
    }
    readFromFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                fs.readFile(filePath, 'utf-8', (err, data) => {
                    if (err) {
                        console.error('ERROR! ðŸ’¥ ! Cannot read file: ' + filePath);
                        reject(err);
                    }
                    resolve(data);
                });
            });
        });
    }
    getFileFullPath(fileName) {
        // fileName may have a / in the beginning, so we want to remove it first
        if (fileName.charAt(0) === '/') {
            fileName = fileName.slice(1);
        }
        return join(this.cacheFolderPath, '/', fileName);
    }
}
function findIndexHtmlFilesRecursively(path) {
    const data = [];
    try {
        const files = fs.readdirSync(path);
        files.forEach((file) => {
            const filePath = join(path, file);
            if (fs.statSync(filePath).isDirectory()) {
                data.push(...findIndexHtmlFilesRecursively(filePath));
            }
            else if (file.includes('index.html')) {
                const html = fs.readFileSync(filePath, 'utf8');
                data.push({ path: filePath, html });
            }
        });
    }
    catch (err) {
        console.error('ERROR! ðŸ’¥ ! Cannot read folder: ' + path);
        return [];
    }
    return data;
}
function convertRouteToFileName(route) {
    return route.replace(new RegExp('/', 'g'), '__');
}

class InMemoryCacheHandler {
    constructor() {
        this.cache = new Map();
    }
    add(url, html, options = { revalidate: null }) {
        const htmlWithMsg = html + cacheMsg(options.revalidate);
        return new Promise((resolve, reject) => {
            const cacheData = {
                html: htmlWithMsg,
                options,
                createdAt: Date.now()
            };
            this.cache.set(url, cacheData);
            resolve();
        });
    }
    get(url) {
        return new Promise((resolve, reject) => {
            if (this.cache.has(url)) {
                resolve(this.cache.get(url));
            }
            reject('This url does not exist in cache!');
        });
    }
    getAll() {
        return new Promise((resolve, reject) => {
            resolve(Array.from(this.cache.keys()));
        });
    }
    has(url) {
        return new Promise((resolve, reject) => {
            resolve(this.cache.has(url));
        });
    }
    delete(url) {
        return new Promise((resolve, reject) => {
            resolve(this.cache.delete(url));
        });
    }
}
const cacheMsg = (revalidateTime) => {
    const time = new Date().toISOString()
        .replace(/T/, ' ')
        .replace(/\..+/, '');
    let msg = '<!-- ';
    msg += `\nðŸš€ NgxISR: Served from cache! \nâŒ› Last updated: ${time}. `;
    if (revalidateTime) {
        msg += `\nâ­ï¸ Next refresh is after ${revalidateTime} seconds. `;
    }
    msg += ' \n-->';
    return msg;
};

const EXTRA_PROVIDERS = [
    { provide: ÉµSERVER_CONTEXT, useValue: 'ngx-isr' },
];
// helper method that generates html of an url
const renderUrl = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { req, res, url, indexHtml, providers } = options;
    // we need to override url of req with the one we have in parameters
    req.url = url;
    req.originalUrl = url;
    const BASE_URL_PROVIDER = {
        provide: APP_BASE_HREF,
        useValue: req.baseUrl,
    };
    return new Promise((resolve, reject) => {
        const allProviders = providers
            ? [...providers, ...EXTRA_PROVIDERS] // if providers are provided, we add them to the list
            : [...EXTRA_PROVIDERS, BASE_URL_PROVIDER]; // if not, we add the default providers
        res.render(indexHtml, { req, providers: allProviders }, (err, html) => __awaiter(void 0, void 0, void 0, function* () {
            if (err) {
                reject(err);
            }
            resolve(html);
        }));
    });
});

class CacheRegeneration {
    constructor(cache, indexHtml) {
        this.cache = cache;
        this.indexHtml = indexHtml;
        // TODO: make this pluggable because on serverless environments we can't share memory between functions
        // so we need to use a database or redis cache to store the urls that are on hold if we want to use this feature
        this.urlsOnHold = []; // urls that have regeneration loading
    }
    regenerate(req, res, cacheData, logger, providers) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url } = req;
            if (this.urlsOnHold.includes(url)) {
                logger.log('Another regeneration is on-going...');
                return;
            }
            const { options } = cacheData;
            const { revalidate } = options;
            logger.log(`The url: ${url} is being regenerated.`);
            this.urlsOnHold.push(url);
            renderUrl({ req, res, url, indexHtml: this.indexHtml, providers }).then((html) => {
                const { errors } = getISROptions(html);
                if (errors === null || errors === void 0 ? void 0 : errors.length) {
                    logger.log('ðŸ’¥ ERROR: Url: ' + url + ' was not regenerated!', errors);
                    return;
                }
                // add the regenerated page to cache
                this.cache.add(req.url, html, { revalidate }).then(() => {
                    // remove url from urlsOnHold
                    this.urlsOnHold = this.urlsOnHold.filter((x) => x !== url);
                    logger.log('Url: ' + url + ' was regenerated!');
                });
            });
        });
    }
}

class ISRLogger {
    constructor(showLogs) {
        this.showLogs = showLogs;
    }
    log(message, ...optionalParams) {
        this.showLogs && console.log(message, ...optionalParams);
    }
}

class ISRHandler {
    constructor(config) {
        var _a;
        if (!config) {
            throw new Error('Provide ISRHandlerConfig!');
        }
        this.isrConfig = config;
        this.logger = new ISRLogger((_a = config === null || config === void 0 ? void 0 : config.enableLogging) !== null && _a !== void 0 ? _a : false);
        // if skipCachingOnHttpError is not provided it will default to true
        this.isrConfig.skipCachingOnHttpError =
            (config === null || config === void 0 ? void 0 : config.skipCachingOnHttpError) !== false;
        if (config.cache && config.cache instanceof CacheHandler) {
            this.logger.log('Using custom cache handler!');
            this.cache = config.cache;
        }
        else {
            this.logger.log('Using in memory cache handler!');
            this.cache = new InMemoryCacheHandler();
        }
        this.cacheRegeneration = new CacheRegeneration(this.cache, config.indexHtml);
    }
    invalidate(req, res, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const { token, urlsToInvalidate } = extractDataFromBody(req);
            const { indexHtml } = this.isrConfig;
            if (token !== this.isrConfig.invalidateSecretToken) {
                return res.json({ status: 'error', message: 'Your secret token is wrong!!!' });
            }
            if (!urlsToInvalidate || !urlsToInvalidate.length) {
                return res.json({ status: 'error', message: 'Please add `urlsToInvalidate` in the payload!' });
            }
            const notInCache = [];
            const urlWithErrors = {};
            for (const url of urlsToInvalidate) {
                const urlExists = yield this.cache.has(url);
                if (!urlExists) {
                    notInCache.push(url);
                    continue;
                }
                try {
                    // re-render the page again
                    const html = yield renderUrl({ req, res, url, indexHtml, providers: config === null || config === void 0 ? void 0 : config.providers });
                    // get revalidate data in order to set it to cache data
                    const { revalidate, errors } = getISROptions(html);
                    // if there are errors when rendering the site we throw an error
                    if ((errors === null || errors === void 0 ? void 0 : errors.length) && this.isrConfig.skipCachingOnHttpError) {
                        urlWithErrors[url] = errors;
                    }
                    // add the regenerated page to cache
                    yield this.cache.add(req.url, html, { revalidate });
                }
                catch (err) {
                    urlWithErrors[url] = err;
                }
            }
            const invalidatedUrls = urlsToInvalidate.filter(url => !notInCache.includes(url) && !urlWithErrors[url]);
            if (notInCache.length) {
                this.logger.log(`Urls: ${notInCache.join(', ')} does not exist in cache.`);
            }
            if (Object.keys(urlWithErrors).length) {
                this.logger.log(`Urls: ${Object.keys(urlWithErrors).join(', ')} had errors while regenerating!`);
            }
            if (invalidatedUrls.length) {
                this.logger.log(`Urls: ${invalidatedUrls.join(', ')} were regenerated!`);
            }
            const response = { status: 'success', notInCache, urlWithErrors, invalidatedUrls };
            return res.json(response);
        });
    }
    serveFromCache(req, res, next, config) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const cacheData = yield this.cache.get(req.url);
                const { html, options, createdAt } = cacheData;
                // if the cache is expired, we will regenerate it
                if (options.revalidate && options.revalidate > 0) {
                    const lastCacheDateDiff = (Date.now() - createdAt) / 1000; // in seconds
                    if (lastCacheDateDiff > options.revalidate) {
                        yield this.cacheRegeneration.regenerate(req, res, cacheData, this.logger, config === null || config === void 0 ? void 0 : config.providers);
                    }
                }
                // Apply the callback if given
                let finalHtml = html;
                if (config === null || config === void 0 ? void 0 : config.modifyCachedHtml) {
                    const timeStart = performance.now();
                    finalHtml = config.modifyCachedHtml(req, html);
                    const totalTime = performance.now() - timeStart;
                    finalHtml += `<!--\nâ„¹ï¸ NgxISR: This cachedHtml has been modified with modifyCachedHtml()\nâ—ï¸ This resulted into more ${totalTime.toFixed(2)}ms of processing time.\n-->`;
                }
                // Cache exists. Send it.
                this.logger.log(`Page was retrieved from cache: `, req.url);
                return res.send(finalHtml);
            }
            catch (error) {
                // Cache does not exist. Serve user using SSR
                next();
            }
        });
    }
    render(req, res, next, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const renderUrlConfig = {
                req,
                res,
                url: req.url,
                indexHtml: this.isrConfig.indexHtml,
                providers: config === null || config === void 0 ? void 0 : config.providers,
            };
            renderUrl(renderUrlConfig).then((html) => __awaiter(this, void 0, void 0, function* () {
                const { revalidate, errors } = getISROptions(html);
                // Apply the callback if given
                const finalHtml = (config === null || config === void 0 ? void 0 : config.modifyGeneratedHtml) ? config.modifyGeneratedHtml(req, html) : html;
                // if we have any http errors when rendering the site, and we have skipCachingOnHttpError enabled
                // we don't want to cache it, and, we will fall back to client side rendering
                if ((errors === null || errors === void 0 ? void 0 : errors.length) && this.isrConfig.skipCachingOnHttpError) {
                    this.logger.log('Http errors: \n', errors);
                    return res.send(finalHtml);
                }
                // if revalidate is null we won't cache it
                // if revalidate is 0, we will never clear the cache automatically
                // if revalidate is x, we will clear cache every x seconds (after the last request) for that url
                if (revalidate === null || revalidate === undefined) {
                    // don't do !revalidate because it will also catch "0"
                    return res.send(finalHtml);
                }
                // Cache the rendered `html` for this request url to use for subsequent requests
                yield this.cache.add(req.url, finalHtml, { revalidate });
                return res.send(finalHtml);
            }));
        });
    }
}
const extractDataFromBody = (req) => {
    const { urlsToInvalidate, token } = req.body;
    return { urlsToInvalidate, token };
};

class HttpErrorsInterceptor {
    constructor(ngxIsrService) {
        this.ngxIsrService = ngxIsrService;
    }
    intercept(request, next) {
        return next.handle(request).pipe(catchError(err => {
            this.ngxIsrService.addError(err);
            return throwError(() => err);
        }));
    }
}
HttpErrorsInterceptor.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: HttpErrorsInterceptor, deps: [{ token: NgxIsrService }], target: i0.ÉµÉµFactoryTarget.Injectable });
HttpErrorsInterceptor.Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: HttpErrorsInterceptor });
i0.ÉµÉµngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: HttpErrorsInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: NgxIsrService }]; } });
const HTTP_ERROR_PROVIDER_ISR = {
    provide: HTTP_INTERCEPTORS,
    useClass: HttpErrorsInterceptor,
    multi: true,
};

function addIsrDataBeforeSerialized(isrService, doc) {
    return () => addISRDataToBody(doc, isrService.getState());
}
// append script with revalidate and errors data for the current route
function addISRDataToBody(doc, { revalidate, errors, extra }) {
    return new Promise(resolve => {
        const script = doc.createElement('script');
        script.id = 'isr-state';
        script.setAttribute('type', 'application/json');
        let toBeSerialized = { revalidate };
        if (errors.length)
            toBeSerialized = Object.assign(Object.assign({}, toBeSerialized), { errors });
        if (Object.keys(extra).length)
            toBeSerialized = Object.assign(Object.assign({}, toBeSerialized), { extra });
        script.textContent = JSON.stringify(toBeSerialized);
        doc.body.appendChild(script);
        resolve();
    });
}

class NgxIsrModule {
    constructor(isrService) {
        this.isrService = isrService;
    }
    static forRoot() {
        return {
            ngModule: NgxIsrModule,
            providers: [
                NgxIsrService,
                HTTP_ERROR_PROVIDER_ISR,
                {
                    provide: BEFORE_APP_SERIALIZED,
                    useFactory: addIsrDataBeforeSerialized,
                    multi: true,
                    deps: [NgxIsrService, DOCUMENT]
                },
            ]
        };
    }
}
NgxIsrModule.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrModule, deps: [{ token: NgxIsrService }], target: i0.ÉµÉµFactoryTarget.NgModule });
NgxIsrModule.Éµmod = i0.ÉµÉµngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrModule });
NgxIsrModule.Éµinj = i0.ÉµÉµngDeclareInjector({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrModule, providers: [NgxIsrService] });
i0.ÉµÉµngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgxIsrModule, decorators: [{
            type: NgModule,
            args: [{ providers: [NgxIsrService] }]
        }], ctorParameters: function () { return [{ type: NgxIsrService }]; } });

/*
 * Public API Surface of ngx-isr
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CacheHandler, FileSystemCacheHandler, ISRHandler, InMemoryCacheHandler, NgxIsrModule, NgxIsrService };
//# sourceMappingURL=ngx-isr.mjs.map
//# sourceMappingURL=ngx-isr.mjs.map
